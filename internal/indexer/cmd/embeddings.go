package cmd

import (
	"context"
	"fmt"
	"os"
	"sort"

	"github.com/hybridgroup/yzma/pkg/llama"
	"github.com/spf13/cobra"

	"github.com/wethinkt/go-thinkt/internal/config"
	indexer "github.com/wethinkt/go-thinkt/internal/indexer"
	"github.com/wethinkt/go-thinkt/internal/indexer/embedding"
)

var embeddingsCmd = &cobra.Command{
	Use:   "embeddings",
	Short: "Manage the embeddings database",
}

var embeddingsPurgeCmd = &cobra.Command{
	Use:   "purge",
	Short: "Remove embeddings from previous models",
	Long:  "Deletes stale embeddings that were generated by a model other than the currently configured one. This frees disk space without affecting search results.",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}

		embDB, err := getReadOnlyEmbeddingsDB()
		if err != nil {
			return fmt.Errorf("embeddings database not available: %w", err)
		}
		embDB.Close()

		// Re-open read-write for the purge. We need to look up the dim from existing data,
		// since we don't load the model. Use a default dim for schema (the table already exists).
		spec, err := embedding.LookupModel(cfg.Embedding.Model)
		if err != nil {
			return err
		}
		embDBRW, err := getEmbeddingsDB(spec.Dim)
		if err != nil {
			return fmt.Errorf("embeddings database not available: %w", err)
		}
		defer embDBRW.Close()

		count, err := indexer.PurgeStaleEmbeddingsByModel(context.Background(), embDBRW, cfg.Embedding.Model)
		if err != nil {
			return fmt.Errorf("purge failed: %w", err)
		}

		if count == 0 {
			fmt.Println("No stale embeddings to purge.")
		} else {
			fmt.Printf("Purged %d stale embeddings.\n", count)
		}
		return nil
	},
}

var embeddingsEnableCmd = &cobra.Command{
	Use:   "enable",
	Short: "Enable embedding",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		if cfg.Embedding.Enabled {
			fmt.Printf("Embedding is already enabled (model: %s).\n", cfg.Embedding.Model)
			return nil
		}
		cfg.Embedding.Enabled = true
		if err := config.Save(cfg); err != nil {
			return fmt.Errorf("failed to save config: %w", err)
		}
		fmt.Printf("Embedding enabled (model: %s).\n", cfg.Embedding.Model)
		notifyServerConfigReload()
		return nil
	},
}

var embeddingsDisableCmd = &cobra.Command{
	Use:   "disable",
	Short: "Disable embedding",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		if !cfg.Embedding.Enabled {
			fmt.Println("Embedding is already disabled.")
			return nil
		}
		cfg.Embedding.Enabled = false
		if err := config.Save(cfg); err != nil {
			return fmt.Errorf("failed to save config: %w", err)
		}
		fmt.Println("Embedding disabled.")
		notifyServerConfigReload()
		return nil
	},
}

var embeddingsModelCmd = &cobra.Command{
	Use:   "model [model-id]",
	Short: "Show or change the embedding model",
	Long: `Without arguments, lists available models and shows which is active.
With an argument, switches to the specified model.

Available models:
  nomic-embed-text-v1.5   768-dim, mean pooling, ~146 MB (default)
  qwen3-embedding-0.6b    1024-dim, last-token pooling, ~640 MB`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}

		if len(args) == 0 {
			// List mode
			printModelList(cfg.Embedding.Model)
			return nil
		}

		// Switch mode
		newModel := args[0]
		if _, err := embedding.LookupModel(newModel); err != nil {
			fmt.Fprintf(os.Stderr, "Unknown model %q. Available models:\n\n", newModel)
			printModelList(cfg.Embedding.Model)
			return fmt.Errorf("unknown model %q", newModel)
		}

		if cfg.Embedding.Model == newModel {
			fmt.Printf("Already using %s.\n", newModel)
			return nil
		}

		old := cfg.Embedding.Model
		cfg.Embedding.Model = newModel
		if err := config.Save(cfg); err != nil {
			return fmt.Errorf("failed to save config: %w", err)
		}

		fmt.Printf("Switched embedding model: %s â†’ %s\n", old, newModel)
		if cfg.Embedding.Enabled {
			fmt.Println("The model will be downloaded on next sync if needed.")
			notifyServerConfigReload()
		}
		return nil
	},
	ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) > 0 {
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		var ids []string
		for id := range embedding.KnownModels {
			ids = append(ids, id)
		}
		sort.Strings(ids)
		return ids, cobra.ShellCompDirectiveNoFileComp
	},
}

func printModelList(activeModel string) {
	// Sort model IDs for stable output.
	ids := make([]string, 0, len(embedding.KnownModels))
	for id := range embedding.KnownModels {
		ids = append(ids, id)
	}
	sort.Strings(ids)

	for _, id := range ids {
		spec := embedding.KnownModels[id]
		marker := "  "
		if id == activeModel {
			marker = "* "
		}
		pooling := "mean"
		if spec.PoolingType != llama.PoolingTypeMean {
			pooling = "last-token"
		}
		fmt.Printf("%s%-25s %d-dim, %s pooling\n", marker, id, spec.Dim, pooling)
	}
}

func init() {
	embeddingsCmd.AddCommand(embeddingsPurgeCmd)
	embeddingsCmd.AddCommand(embeddingsEnableCmd)
	embeddingsCmd.AddCommand(embeddingsDisableCmd)
	embeddingsCmd.AddCommand(embeddingsModelCmd)
	rootCmd.AddCommand(embeddingsCmd)
}
