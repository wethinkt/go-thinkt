package cmd

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"charm.land/lipgloss/v2"
	"github.com/hybridgroup/yzma/pkg/llama"
	"github.com/spf13/cobra"

	"github.com/wethinkt/go-thinkt/internal/cmd"
	"github.com/wethinkt/go-thinkt/internal/config"
	indexer "github.com/wethinkt/go-thinkt/internal/indexer"
	"github.com/wethinkt/go-thinkt/internal/indexer/db"
	"github.com/wethinkt/go-thinkt/internal/indexer/embedding"
	"github.com/wethinkt/go-thinkt/internal/indexer/rpc"
	"github.com/wethinkt/go-thinkt/internal/tui"
	"github.com/wethinkt/go-thinkt/internal/tui/theme"
)

var embeddingsCmd = &cobra.Command{
	Use:   "embeddings",
	Short: "Manage embedding model, storage, and sync",
	Long: `Manage the embedding infrastructure: model selection, sync, and storage.

Use 'embeddings list' to see available models.
Use 'embeddings sync' to generate embeddings for indexed sessions.
Use 'embeddings status' to check model, download state, and progress.
Use 'semantic search' to query sessions using the generated embeddings.`,
	Args: cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		return embeddingsListCmd.RunE(cmd, args)
	},
}

var embeddingsListJSON bool

var embeddingsListCmd = &cobra.Command{
	Use:   "list",
	Short: "List available embedding models",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		if embeddingsListJSON {
			return printModelListJSON(cfg.Embedding.Model)
		}
		printModelList(cfg.Embedding.Model)
		return nil
	},
}

var embeddingsPurgeCmd = &cobra.Command{
	Use:   "purge",
	Short: "Remove embeddings from previous models",
	Long:  "Deletes stale embeddings that were generated by a model other than the currently configured one. This frees disk space without affecting search results.",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		activeModel := cfg.Embedding.Model
		activePath := db.EmbeddingsPathForModel(embDBDir, activeModel)

		files, err := filepath.Glob(filepath.Join(embDBDir, "*.duckdb"))
		if err != nil {
			return fmt.Errorf("glob embeddings dir: %w", err)
		}

		var purged int
		for _, f := range files {
			if filepath.Clean(f) == filepath.Clean(activePath) {
				continue
			}
			if err := os.Remove(f); err != nil {
				fmt.Fprintf(os.Stderr, "warning: could not remove %s: %v\n", f, err)
			} else {
				purged++
				fmt.Printf("Removed: %s\n", filepath.Base(f))
			}
		}

		if purged == 0 {
			fmt.Println("No stale embedding databases to purge.")
		} else {
			fmt.Printf("Purged %d stale embedding database(s).\n", purged)
		}
		return nil
	},
}

var embeddingsEnableCmd = &cobra.Command{
	Use:   "enable",
	Short: "Enable embedding",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		if cfg.Embedding.Enabled {
			fmt.Printf("Embedding is already enabled (model: %s).\n", cfg.Embedding.Model)
			return nil
		}
		cfg.Embedding.Enabled = true
		if err := config.Save(cfg); err != nil {
			return fmt.Errorf("failed to save config: %w", err)
		}
		fmt.Printf("Embedding enabled (model: %s).\n", cfg.Embedding.Model)
		notifyServerConfigReload()
		return nil
	},
}

var embeddingsDisableCmd = &cobra.Command{
	Use:   "disable",
	Short: "Disable embedding",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		if !cfg.Embedding.Enabled {
			fmt.Println("Embedding is already disabled.")
			return nil
		}
		cfg.Embedding.Enabled = false
		if err := config.Save(cfg); err != nil {
			return fmt.Errorf("failed to save config: %w", err)
		}
		fmt.Println("Embedding disabled.")
		notifyServerConfigReload()
		return nil
	},
}

var embeddingsModelCmd = &cobra.Command{
	Use:   "model [model-id]",
	Short: "Switch the embedding model",
	Long: `Switch to a different embedding model.

Without arguments, opens an interactive picker.
With an argument, switches directly to the specified model.`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}

		var newModel string
		if len(args) > 0 {
			newModel = args[0]
		} else {
			selected, err := pickEmbeddingModel(cfg.Embedding.Model)
			if err != nil {
				return err
			}
			if selected == nil {
				return nil // cancelled
			}
			newModel = *selected
		}
		if _, err := embedding.LookupModel(newModel); err != nil {
			fmt.Fprintf(os.Stderr, "Unknown model %q. Available models:\n\n", newModel)
			printModelList(cfg.Embedding.Model)
			cmd.SilenceErrors = true
			return fmt.Errorf("unknown model %q", newModel)
		}

		if cfg.Embedding.Model == newModel {
			fmt.Printf("Already using %s.\n", newModel)
			return nil
		}

		old := cfg.Embedding.Model
		cfg.Embedding.Model = newModel
		if err := config.Save(cfg); err != nil {
			return fmt.Errorf("failed to save config: %w", err)
		}

		fmt.Printf("Switched embedding model: %s → %s\n", old, newModel)
		if cfg.Embedding.Enabled {
			fmt.Println("The model will be downloaded on next sync if needed.")
			notifyServerConfigReload()
		}
		return nil
	},
	ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) > 0 {
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		var ids []string
		for id := range embedding.KnownModels {
			ids = append(ids, id)
		}
		sort.Strings(ids)
		return ids, cobra.ShellCompDirectiveNoFileComp
	},
}

func printModelList(activeModel string) {
	t := theme.Current()
	accentStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(t.GetAccent())).Bold(true)
	primaryStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(t.TextPrimary.Fg))
	mutedStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(t.TextMuted.Fg))

	// Sort model IDs for stable output.
	ids := make([]string, 0, len(embedding.KnownModels))
	for id := range embedding.KnownModels {
		ids = append(ids, id)
	}
	sort.Strings(ids)

	maxLen := 0
	for _, id := range ids {
		if len(id) > maxLen {
			maxLen = len(id)
		}
	}

	for _, id := range ids {
		spec := embedding.KnownModels[id]
		pooling := "mean"
		if spec.PoolingType != llama.PoolingTypeMean {
			pooling = "last-token"
		}
		detail := fmt.Sprintf("%d-dim, %s pooling", spec.Dim, pooling)

		if id == activeModel {
			fmt.Printf("%s %s  %s\n", accentStyle.Render("*"), primaryStyle.Width(maxLen).Render(id), mutedStyle.Render(detail))
		} else {
			fmt.Printf("  %s  %s\n", mutedStyle.Width(maxLen).Render(id), mutedStyle.Render(detail))
		}
	}
}

func pickEmbeddingModel(activeModel string) (*string, error) {
	ids := make([]string, 0, len(embedding.KnownModels))
	for id := range embedding.KnownModels {
		ids = append(ids, id)
	}
	sort.Strings(ids)

	var options []tui.ModelOption
	for _, id := range ids {
		spec := embedding.KnownModels[id]
		pooling := "mean"
		if spec.PoolingType != llama.PoolingTypeMean {
			pooling = "last-token"
		}
		options = append(options, tui.ModelOption{
			ID:     id,
			Detail: fmt.Sprintf("%d-dim, %s pooling", spec.Dim, pooling),
			Active: id == activeModel,
		})
	}

	return tui.PickModel(options)
}

func printModelListJSON(activeModel string) error {
	ids := make([]string, 0, len(embedding.KnownModels))
	for id := range embedding.KnownModels {
		ids = append(ids, id)
	}
	sort.Strings(ids)

	type modelInfo struct {
		ID      string `json:"id"`
		Dim     int    `json:"dim"`
		Pooling string `json:"pooling"`
		Active  bool   `json:"active"`
	}

	var models []modelInfo
	for _, id := range ids {
		spec := embedding.KnownModels[id]
		pooling := "mean"
		if spec.PoolingType != llama.PoolingTypeMean {
			pooling = "last-token"
		}
		models = append(models, modelInfo{
			ID:      id,
			Dim:     spec.Dim,
			Pooling: pooling,
			Active:  id == activeModel,
		})
	}

	return json.NewEncoder(os.Stdout).Encode(map[string]any{
		"active": activeModel,
		"models": models,
	})
}

var embeddingsStatusJSON bool

type modelStats struct {
	Model    string `json:"model"`
	Count    int    `json:"count"`
	Sessions int    `json:"sessions"`
	Dim      int    `json:"dim"`
}

var embeddingsStatusCmd = &cobra.Command{
	Use:   "status",
	Short: "Show embedding configuration and status",
	Args:  cobra.NoArgs,
	RunE: func(cmdObj *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}

		modelID := cfg.Embedding.Model
		spec, _ := embedding.LookupModel(modelID)
		modelPath, _ := embedding.ModelPathForID(modelID)
		_, statErr := os.Stat(modelPath)
		modelDownloaded := statErr == nil

		// Embedding stats per model from DB
		var perModel []modelStats
		var totalEmbeddings int
		var totalDBSize int64

		if files, err := filepath.Glob(filepath.Join(embDBDir, "*.duckdb")); err == nil {
			for _, f := range files {
				fi, statErr := os.Stat(f)
				if statErr != nil {
					continue
				}
				totalDBSize += fi.Size()

				base := filepath.Base(f)
				mID := strings.TrimSuffix(base, ".duckdb")

				if embDB, err := db.OpenReadOnly(f); err == nil {
					var count, sessions int
					_ = embDB.QueryRow("SELECT count(*), count(DISTINCT session_id) FROM embeddings").Scan(&count, &sessions)
					spec, _ := embedding.LookupModel(mID)
					perModel = append(perModel, modelStats{
						Model:    mID,
						Count:    count,
						Sessions: sessions,
						Dim:      spec.Dim,
					})
					totalEmbeddings += count
					embDB.Close()
				}
			}
		}

		// Server status (if running)
		var serverRunning bool
		var serverEmbedding bool
		var embedProgress *rpc.ProgressInfo
		var serverModel string
		if rpc.ServerAvailable() {
			serverRunning = true
			resp, err := rpc.Call(rpc.MethodStatus, nil, nil)
			if err == nil && resp.OK {
				var status rpc.StatusData
				if err := json.Unmarshal(resp.Data, &status); err == nil {
					serverEmbedding = status.Embedding
					embedProgress = status.EmbedProgress
					serverModel = status.Model
				}
			}
		}

		if embeddingsStatusJSON {
			out := map[string]any{
				"enabled":             cfg.Embedding.Enabled,
				"model":               modelID,
				"model_dim":           spec.Dim,
				"model_downloaded":    modelDownloaded,
				"total_embeddings":    totalEmbeddings,
				"embeddings_by_model": perModel,
				"db_size_bytes":       totalDBSize,
				"server_running":      serverRunning,
				"server_embedding":    serverEmbedding,
			}
			if serverModel != "" {
				out["server_model"] = serverModel
			}
			if embedProgress != nil {
				out["progress"] = embedProgress
			}
			return json.NewEncoder(os.Stdout).Encode(out)
		}

		if cfg.Embedding.Enabled {
			fmt.Println("Embedding: enabled")
		} else {
			fmt.Println("Embedding: disabled")
		}
		fmt.Printf("Model:     %s (%d dim)\n", modelID, spec.Dim)
		if modelDownloaded {
			fmt.Println("Download:  ready")
		} else {
			fmt.Println("Download:  not downloaded")
		}
		if totalEmbeddings == 0 {
			fmt.Println("Stored:    0 embeddings")
		} else {
			fmt.Printf("Stored:    %d embeddings across %d sessions", totalEmbeddings, totalSessions(perModel))
			if totalDBSize > 0 {
				fmt.Printf(" (%s on disk)", formatBytes(totalDBSize))
			}
			fmt.Println()
			if len(perModel) > 1 {
				for _, ms := range perModel {
					marker := "  "
					if ms.Model == modelID {
						marker = "* "
					}
					fmt.Printf("           %s%s: %d embeddings, %d sessions\n", marker, ms.Model, ms.Count, ms.Sessions)
				}
			}
		}

		if serverRunning {
			if serverModel != "" && serverModel != modelID {
				fmt.Printf("Server:    running (model: %s)\n", serverModel)
			} else if serverEmbedding {
				fmt.Print("Server:    embedding")
				if embedProgress != nil {
					fmt.Printf(" %d/%d sessions", embedProgress.Done, embedProgress.Total)
					if embedProgress.ChunksTotal > 0 {
						fmt.Printf("  %d/%d chunks", embedProgress.ChunksDone, embedProgress.ChunksTotal)
					}
					if embedProgress.SessionID != "" {
						sid := embedProgress.SessionID
						if len(sid) > 8 {
							sid = sid[:8]
						}
						fmt.Printf(" [%s]", sid)
					}
				}
				fmt.Println()
			} else {
				fmt.Println("Server:    idle")
			}
		} else {
			fmt.Println("Server:    not running")
		}

		return nil
	},
}

var embeddingsSyncCmd = &cobra.Command{
	Use:   "sync",
	Short: "Run embedding sync (download model if needed, embed all sessions)",
	Args:  cobra.NoArgs,
	RunE: func(cmdObj *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}

		// Try RPC first
		if rpc.ServerAvailable() {
			sp := NewSyncProgress()
			var progressFn func(rpc.Progress)
			if sp.ShouldShowProgress(quiet, verbose) {
				var lastSessionDone, lastSessionTotal, lastEntries int
				var sessionStart time.Time
				progressFn = func(p rpc.Progress) {
					var data struct {
						ModelDownload bool    `json:"model_download"`
						Percent       float64 `json:"percent"`
						Done          int     `json:"done"`
						Total         int     `json:"total"`
						Chunks        int     `json:"chunks"`
						Entries       int     `json:"entries"`
						ChunksDone    int     `json:"chunks_done"`
						ChunksTotal   int     `json:"chunks_total"`
						TokensDone    int     `json:"tokens_done"`
						SessionID     string  `json:"session_id"`
						ElapsedMs     int64   `json:"elapsed_ms"`
					}
					if err := json.Unmarshal(p.Data, &data); err == nil {
						if data.ModelDownload {
							sp.RenderDownload(cfg.Embedding.Model, data.Percent/100)
						} else if data.ChunksTotal > 0 {
							sid := data.SessionID
							if len(sid) > 8 {
								sid = sid[:8]
							}
							detail := fmt.Sprintf("%s · %d entries · %d/%d chunks", sid, lastEntries, data.ChunksDone, data.ChunksTotal)
							if data.TokensDone > 0 && !sessionStart.IsZero() {
								if secs := time.Since(sessionStart).Seconds(); secs > 0 {
									detail += fmt.Sprintf("  %.0f tok/s", float64(data.TokensDone)/secs)
								}
							}
							sp.RenderEmbedding(lastSessionDone, lastSessionTotal, detail)
						} else if data.Total > 0 {
							lastSessionDone = data.Done
							lastSessionTotal = data.Total
							sid := data.SessionID
							if len(sid) > 8 {
								sid = sid[:8]
							}
							if data.ElapsedMs > 0 {
								elapsed := time.Duration(data.ElapsedMs) * time.Millisecond
								detail := fmt.Sprintf("%s · %d chunks (%s)", sid, data.Chunks, elapsed.Round(time.Millisecond))
								sp.RenderEmbedding(data.Done, data.Total, detail)
							} else {
								lastEntries = data.Entries
								sessionStart = time.Now()
								detail := fmt.Sprintf("%s · %d entries", sid, data.Entries)
								sp.RenderEmbedding(data.Done, data.Total, detail)
							}
						}
					}
				}
			}
			resp, err := rpc.Call(rpc.MethodEmbedSync, rpc.EmbedSyncParams{}, progressFn)
			if err != nil {
				if sp.ShouldShowProgress(quiet, verbose) {
					sp.Finish()
				}
				fmt.Fprintf(os.Stderr, "RPC embed_sync failed, falling back to inline: %v\n", err)
			} else if !resp.OK {
				if sp.ShouldShowProgress(quiet, verbose) {
					sp.Finish()
				}
				return fmt.Errorf("embed_sync: %s", resp.Error)
			} else {
				if sp.ShouldShowProgress(quiet, verbose) {
					sp.Finish()
				}
				if !quiet {
					fmt.Println("Embedding sync complete (via server).")
				}
				return nil
			}
		}

		// Inline fallback

		if !cfg.Embedding.Enabled {
			return fmt.Errorf("embedding is not enabled (run: thinkt-indexer embeddings enable)")
		}

		modelID := cfg.Embedding.Model
		dlSp := NewSyncProgress()
		if err := embedding.EnsureModel(modelID, func(downloaded, total int64) {
			if total > 0 && dlSp.ShouldShowProgress(quiet, verbose) {
				dlSp.RenderDownload(modelID, float64(downloaded)/float64(total))
			}
		}); err != nil {
			return fmt.Errorf("failed to download embedding model: %w", err)
		}
		if dlSp.ShouldShowProgress(quiet, verbose) {
			dlSp.Finish()
		}

		embedder, err := embedding.NewEmbedder(modelID, "")
		if err != nil {
			return fmt.Errorf("failed to create embedder: %w", err)
		}
		defer embedder.Close()

		database, err := getDB()
		if err != nil {
			return err
		}
		defer database.Close()

		embDB, err := getEmbeddingsDB(modelID, embedder.Dim())
		if err != nil {
			return fmt.Errorf("embeddings database is locked by another process; use 'thinkt-indexer serve' to allow concurrent access: %w", err)
		}
		defer embDB.Close()

		registry := cmd.CreateSourceRegistryFiltered(cfg.Indexer.Sources)
		ingester := indexer.NewIngester(database, embDB, registry, embedder)
		ingester.Verbose = verbose

		ctx := context.Background()

		sp := NewSyncProgress()
		if sp.ShouldShowProgress(quiet, verbose) {
			var inlineDone, inlineTotal, inlineEntries int
			var inlineSessionStart time.Time
			ingester.OnEmbedProgress = func(done, total, chunks, entries int, sessionID, sessionPath string, elapsed time.Duration) {
				inlineDone = done
				inlineTotal = total
				sid := sessionID[:min(8, len(sessionID))]
				if elapsed == 0 {
					inlineEntries = entries
					inlineSessionStart = time.Now()
					sp.RenderEmbedding(done, total, fmt.Sprintf("%s · %d entries", sid, entries))
				} else {
					sp.RenderEmbedding(done, total, fmt.Sprintf("%s · %d chunks (%s)", sid, chunks, elapsed.Round(time.Millisecond)))
				}
			}
			ingester.OnEmbedChunkProgress = func(chunksDone, chunksTotal, tokensDone int, sessionID string) {
				sid := sessionID[:min(8, len(sessionID))]
				detail := fmt.Sprintf("%s · %d entries · %d/%d chunks", sid, inlineEntries, chunksDone, chunksTotal)
				if tokensDone > 0 && !inlineSessionStart.IsZero() {
					if secs := time.Since(inlineSessionStart).Seconds(); secs > 0 {
						detail += fmt.Sprintf("  %.0f tok/s", float64(tokensDone)/secs)
					}
				}
				sp.RenderEmbedding(inlineDone, inlineTotal, detail)
			}
		}

		if err := ingester.EmbedAllSessions(ctx); err != nil {
			return fmt.Errorf("embedding error: %w", err)
		}

		if sp.ShouldShowProgress(quiet, verbose) {
			sp.Finish()
		}

		if !quiet {
			fmt.Println("Embedding sync complete.")
		}
		return nil
	},
}

func totalSessions(models []modelStats) int {
	// Can't just sum — sessions may overlap across models.
	// But as an approximation it's fine; exact would require a DB query.
	total := 0
	for _, ms := range models {
		total += ms.Sessions
	}
	return total
}

func formatBytes(b int64) string {
	const (
		kb = 1024
		mb = 1024 * kb
		gb = 1024 * mb
	)
	switch {
	case b >= gb:
		return fmt.Sprintf("%.1f GB", float64(b)/float64(gb))
	case b >= mb:
		return fmt.Sprintf("%.1f MB", float64(b)/float64(mb))
	case b >= kb:
		return fmt.Sprintf("%.1f KB", float64(b)/float64(kb))
	default:
		return fmt.Sprintf("%d B", b)
	}
}

func init() {
	embeddingsCmd.Flags().BoolVar(&embeddingsListJSON, "json", false, "Output as JSON")
	embeddingsListCmd.Flags().BoolVar(&embeddingsListJSON, "json", false, "Output as JSON")
	embeddingsCmd.AddCommand(embeddingsListCmd)
	embeddingsCmd.AddCommand(embeddingsPurgeCmd)
	embeddingsCmd.AddCommand(embeddingsEnableCmd)
	embeddingsCmd.AddCommand(embeddingsDisableCmd)
	embeddingsCmd.AddCommand(embeddingsModelCmd)
	embeddingsStatusCmd.Flags().BoolVar(&embeddingsStatusJSON, "json", false, "Output as JSON")
	embeddingsCmd.AddCommand(embeddingsStatusCmd)
	embeddingsCmd.AddCommand(embeddingsSyncCmd)
	rootCmd.AddCommand(embeddingsCmd)
}
