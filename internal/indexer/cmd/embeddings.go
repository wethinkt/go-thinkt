package cmd

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/tabwriter"
	"time"

	"github.com/hybridgroup/yzma/pkg/llama"
	"github.com/spf13/cobra"

	"github.com/wethinkt/go-thinkt/internal/cmd"
	"github.com/wethinkt/go-thinkt/internal/config"
	thinktI18n "github.com/wethinkt/go-thinkt/internal/i18n"
	indexer "github.com/wethinkt/go-thinkt/internal/indexer"
	"github.com/wethinkt/go-thinkt/internal/indexer/db"
	"github.com/wethinkt/go-thinkt/internal/indexer/embedding"
	"github.com/wethinkt/go-thinkt/internal/indexer/rpc"
	"github.com/wethinkt/go-thinkt/internal/tui"
)

var embeddingsCmd = &cobra.Command{
	Use:   "embeddings",
	Short: "Manage embedding model, storage, and sync",
	Long: `Manage the embedding infrastructure: model selection, sync, and storage.

Use 'embeddings list' to see available models.
Use 'embeddings sync' to generate embeddings for indexed sessions.
Use 'embeddings status' to check model, download state, and progress.
Use 'semantic search' to query sessions using the generated embeddings.`,
	Args: cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		return embeddingsListCmd.RunE(cmd, args)
	},
}

var embeddingsListJSON bool

var embeddingsListCmd = &cobra.Command{
	Use:   "list",
	Short: "List available embedding models",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		if embeddingsListJSON {
			return printModelListJSON(cfg.Embedding.Model)
		}
		printModelList(cfg.Embedding.Model)
		return nil
	},
}

var embeddingsPurgeCmd = &cobra.Command{
	Use:   "purge",
	Short: "Remove embeddings from previous models",
	Long:  "Deletes stale embeddings that were generated by a model other than the currently configured one. This frees disk space without affecting search results.",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		activeModel := cfg.Embedding.Model
		activePath := db.EmbeddingsPathForModel(embDBDir, activeModel)

		files, err := filepath.Glob(filepath.Join(embDBDir, "*.duckdb"))
		if err != nil {
			return fmt.Errorf("glob embeddings dir: %w", err)
		}

		var purged int
		for _, f := range files {
			if filepath.Clean(f) == filepath.Clean(activePath) {
				continue
			}
			if err := os.Remove(f); err != nil {
				fmt.Fprint(os.Stderr, thinktI18n.Tf("indexer.embeddings.purge.removeWarning", "warning: could not remove %s: %v\n", f, err))
			} else {
				purged++
				fmt.Print(thinktI18n.Tf("indexer.embeddings.purge.removed", "Removed: %s\n", filepath.Base(f)))
			}
		}

		if purged == 0 {
			fmt.Println(thinktI18n.T("indexer.embeddings.purge.noneFound", "No stale embedding databases to purge."))
		} else {
			fmt.Print(thinktI18n.Tf("indexer.embeddings.purge.complete", "Purged %d stale embedding database(s).\n", purged))
		}
		return nil
	},
}

var embeddingsEnableCmd = &cobra.Command{
	Use:   "enable",
	Short: "Enable embedding",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		if cfg.Embedding.Enabled {
			fmt.Print(thinktI18n.Tf("indexer.embeddings.alreadyEnabled", "Embedding is already enabled (model: %s).\n", cfg.Embedding.Model))
			return nil
		}
		cfg.Embedding.Enabled = true
		if err := config.Save(cfg); err != nil {
			return fmt.Errorf("failed to save config: %w", err)
		}
		fmt.Print(thinktI18n.Tf("indexer.embeddings.enabled", "Embedding enabled (model: %s).\n", cfg.Embedding.Model))
		notifyServerConfigReload()
		return nil
	},
}

var embeddingsDisableCmd = &cobra.Command{
	Use:   "disable",
	Short: "Disable embedding",
	Args:  cobra.NoArgs,
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}
		if !cfg.Embedding.Enabled {
			fmt.Println(thinktI18n.T("indexer.embeddings.alreadyDisabled", "Embedding is already disabled."))
			return nil
		}
		cfg.Embedding.Enabled = false
		if err := config.Save(cfg); err != nil {
			return fmt.Errorf("failed to save config: %w", err)
		}
		fmt.Println(thinktI18n.T("indexer.embeddings.disabled", "Embedding disabled."))
		notifyServerConfigReload()
		return nil
	},
}

var embeddingsModelCmd = &cobra.Command{
	Use:   "model [model-id]",
	Short: "Switch the embedding model",
	Long: `Switch to a different embedding model.

Without arguments, opens an interactive picker.
With an argument, switches directly to the specified model.`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}

		var newModel string
		if len(args) > 0 {
			newModel = args[0]
		} else {
			if !isTTY() {
				return fmt.Errorf("%s", thinktI18n.T("indexer.embeddings.model.noTerminal", "interactive model picker requires a terminal; pass model ID as argument"))
			}
			selected, err := pickEmbeddingModel(cfg.Embedding.Model)
			if err != nil {
				return err
			}
			if selected == nil {
				return nil // cancelled
			}
			newModel = *selected
		}
		if _, err := embedding.LookupModel(newModel); err != nil {
			fmt.Fprint(os.Stderr, thinktI18n.Tf("indexer.embeddings.model.unknown", "Unknown model %q. Available models:\n\n", newModel))
			printModelList(cfg.Embedding.Model)
			cmd.SilenceErrors = true
			return fmt.Errorf("unknown model %q", newModel)
		}

		if cfg.Embedding.Model == newModel {
			fmt.Print(thinktI18n.Tf("indexer.embeddings.model.alreadyUsing", "Already using %s.\n", newModel))
			return nil
		}

		old := cfg.Embedding.Model
		cfg.Embedding.Model = newModel
		if err := config.Save(cfg); err != nil {
			return fmt.Errorf("failed to save config: %w", err)
		}

		fmt.Print(thinktI18n.Tf("indexer.embeddings.model.switched", "Switched embedding model: %s → %s\n", old, newModel))
		if cfg.Embedding.Enabled {
			fmt.Println(thinktI18n.T("indexer.embeddings.model.downloadHint", "The model will be downloaded on next sync if needed."))
			notifyServerConfigReload()
		}
		return nil
	},
	ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		if len(args) > 0 {
			return nil, cobra.ShellCompDirectiveNoFileComp
		}
		var ids []string
		for id := range embedding.KnownModels {
			ids = append(ids, id)
		}
		sort.Strings(ids)
		return ids, cobra.ShellCompDirectiveNoFileComp
	},
}

func printModelList(activeModel string) {
	// Sort model IDs for stable output.
	ids := make([]string, 0, len(embedding.KnownModels))
	for id := range embedding.KnownModels {
		ids = append(ids, id)
	}
	sort.Strings(ids)

	// Gather per-model embedding stats from DB files.
	embStats := make(map[string]modelStats)
	if files, err := filepath.Glob(filepath.Join(embDBDir, "*.duckdb")); err == nil {
		for _, f := range files {
			fi, err := os.Stat(f)
			if err != nil {
				continue
			}
			mID := strings.TrimSuffix(filepath.Base(f), ".duckdb")
			if embDB, err := db.OpenReadOnly(f); err == nil {
				var count, sessions int
				_ = embDB.QueryRow("SELECT count(*), count(DISTINCT session_id) FROM embeddings").Scan(&count, &sessions)
				embStats[mID] = modelStats{
					Count:    count,
					Sessions: sessions,
					Size:     fi.Size(),
				}
				embDB.Close()
			}
		}
	}

	w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
	fmt.Fprintf(w, "  %s\t%s\t%s\t%s\t%s\t%s\n",
		thinktI18n.T("indexer.embeddings.header.model", "MODEL"),
		thinktI18n.T("indexer.embeddings.header.dim", "DIM"),
		thinktI18n.T("indexer.embeddings.header.pooling", "POOLING"),
		thinktI18n.T("indexer.embeddings.header.modelSize", "MODEL SIZE"),
		thinktI18n.T("indexer.embeddings.header.sessions", "SESSIONS"),
		thinktI18n.T("indexer.embeddings.header.dbSize", "DB SIZE"),
	)

	for _, id := range ids {
		spec := embedding.KnownModels[id]
		pooling := "mean"
		if spec.PoolingType != llama.PoolingTypeMean {
			pooling = "last-token"
		}

		modelSize := thinktI18n.T("indexer.embeddings.notDownloaded", "not downloaded")
		if size := modelFileSize(id); size >= 0 {
			modelSize = formatBytes(size)
		}

		sessionCol := "-"
		dbSizeCol := "-"
		if st, ok := embStats[id]; ok && st.Count > 0 {
			sessionCol = fmt.Sprintf("%d", st.Sessions)
			dbSizeCol = formatBytes(st.Size)
		}

		marker := " "
		if id == activeModel {
			marker = "*"
		}
		fmt.Fprintf(w, "%s %s\t%d\t%s\t%s\t%s\t%s\n", marker, id, spec.Dim, pooling, modelSize, sessionCol, dbSizeCol)
	}
	w.Flush()
}

// modelFileSize returns the on-disk size for a model, or -1 if not downloaded.
func modelFileSize(modelID string) int64 {
	p, err := embedding.ModelPathForID(modelID)
	if err != nil {
		return -1
	}
	fi, err := os.Stat(p)
	if err != nil {
		return -1
	}
	return fi.Size()
}

func pickEmbeddingModel(activeModel string) (*string, error) {
	ids := make([]string, 0, len(embedding.KnownModels))
	for id := range embedding.KnownModels {
		ids = append(ids, id)
	}
	sort.Strings(ids)

	var options []tui.ModelOption
	for _, id := range ids {
		spec := embedding.KnownModels[id]
		pooling := "mean"
		if spec.PoolingType != llama.PoolingTypeMean {
			pooling = "last-token"
		}
		options = append(options, tui.ModelOption{
			ID:     id,
			Detail: fmt.Sprintf("%d-dim, %s pooling", spec.Dim, pooling),
			Active: id == activeModel,
		})
	}

	return tui.PickModel(options)
}

func printModelListJSON(activeModel string) error {
	ids := make([]string, 0, len(embedding.KnownModels))
	for id := range embedding.KnownModels {
		ids = append(ids, id)
	}
	sort.Strings(ids)

	type modelInfo struct {
		ID         string `json:"id"`
		Dim        int    `json:"dim"`
		Pooling    string `json:"pooling"`
		Active     bool   `json:"active"`
		Downloaded bool   `json:"downloaded"`
		SizeBytes  int64  `json:"size_bytes,omitempty"`
	}

	var models []modelInfo
	for _, id := range ids {
		spec := embedding.KnownModels[id]
		pooling := "mean"
		if spec.PoolingType != llama.PoolingTypeMean {
			pooling = "last-token"
		}
		m := modelInfo{
			ID:      id,
			Dim:     spec.Dim,
			Pooling: pooling,
			Active:  id == activeModel,
		}
		if size := modelFileSize(id); size >= 0 {
			m.Downloaded = true
			m.SizeBytes = size
		}
		models = append(models, m)
	}

	return json.NewEncoder(os.Stdout).Encode(map[string]any{
		"active": activeModel,
		"models": models,
	})
}

var embeddingsStatusJSON bool

type modelStats struct {
	Model        string `json:"model"`
	Count        int    `json:"count"`
	Sessions     int    `json:"sessions"`
	Dim          int    `json:"dim"`
	Size         int64  `json:"size_bytes"`
	Conversation int    `json:"conversation"`
	Reasoning    int    `json:"reasoning"`
}

var embeddingsStatusCmd = &cobra.Command{
	Use:   "status",
	Short: "Show embedding configuration and status",
	Args:  cobra.NoArgs,
	RunE: func(cmdObj *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}

		modelID := cfg.Embedding.Model
		spec, _ := embedding.LookupModel(modelID)
		modelPath, _ := embedding.ModelPathForID(modelID)
		_, statErr := os.Stat(modelPath)
		modelDownloaded := statErr == nil

		// Embedding stats for active model from DB
		var activeStats modelStats
		embPath := db.EmbeddingsPathForModel(embDBDir, modelID)
		if fi, err := os.Stat(embPath); err == nil {
			activeStats.Size = fi.Size()
			if embDB, err := db.OpenReadOnly(embPath); err == nil {
				_ = embDB.QueryRow("SELECT count(*), count(DISTINCT session_id) FROM embeddings").Scan(&activeStats.Count, &activeStats.Sessions)
				_ = embDB.QueryRow("SELECT count(*) FROM embeddings WHERE tier = 'conversation'").Scan(&activeStats.Conversation)
				_ = embDB.QueryRow("SELECT count(*) FROM embeddings WHERE tier = 'reasoning'").Scan(&activeStats.Reasoning)
				embDB.Close()
			}
		}

		// Server status (if running)
		var serverRunning bool
		var serverEmbedding bool
		var embedProgress *rpc.ProgressInfo
		var serverModel string
		if rpc.ServerAvailable() {
			serverRunning = true
			resp, err := rpc.Call(rpc.MethodStatus, nil, nil)
			if err == nil && resp.OK {
				var status rpc.StatusData
				if err := json.Unmarshal(resp.Data, &status); err == nil {
					serverEmbedding = status.Embedding
					embedProgress = status.EmbedProgress
					serverModel = status.Model
				}
			}
		}

		if embeddingsStatusJSON {
			out := map[string]any{
				"enabled":          cfg.Embedding.Enabled,
				"model":            modelID,
				"model_dim":        spec.Dim,
				"model_downloaded": modelDownloaded,
				"embeddings":       activeStats.Count,
				"sessions":         activeStats.Sessions,
				"conversation":     activeStats.Conversation,
				"reasoning":        activeStats.Reasoning,
				"db_size_bytes":    activeStats.Size,
				"server_running":   serverRunning,
				"server_embedding": serverEmbedding,
			}
			if serverModel != "" {
				out["server_model"] = serverModel
			}
			if embedProgress != nil {
				out["progress"] = embedProgress
			}
			return json.NewEncoder(os.Stdout).Encode(out)
		}

		w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)

		enabled := thinktI18n.T("common.status.disabled", "disabled")
		if cfg.Embedding.Enabled {
			enabled = thinktI18n.T("common.status.enabled", "enabled")
		}
		download := thinktI18n.T("indexer.embeddings.notDownloaded", "not downloaded")
		if modelDownloaded {
			download = thinktI18n.T("indexer.embeddings.status.ready", "ready")
		}

		fmt.Fprintf(w, "%s\t%s\n", thinktI18n.T("indexer.embeddings.status.embeddingLabel", "Embedding:"), enabled)
		fmt.Fprintf(w, "%s\t%s (%d dim)\n", thinktI18n.T("indexer.embeddings.status.modelLabel", "Model:"), modelID, spec.Dim)
		fmt.Fprintf(w, "%s\t%s\n", thinktI18n.T("indexer.embeddings.status.downloadLabel", "Download:"), download)
		if activeStats.Count == 0 {
			fmt.Fprintf(w, "%s\t%s\n", thinktI18n.T("indexer.embeddings.status.storedLabel", "Stored:"), thinktI18n.T("indexer.embeddings.status.zeroEmbeddings", "0 embeddings"))
		} else {
			stored := thinktI18n.Tf("indexer.embeddings.status.storedCount", "%d embeddings across %d sessions", activeStats.Count, activeStats.Sessions)
			if activeStats.Size > 0 {
				stored += fmt.Sprintf(" (%s)", formatBytes(activeStats.Size))
			}
			fmt.Fprintf(w, "%s\t%s\n", thinktI18n.T("indexer.embeddings.status.storedLabel", "Stored:"), stored)
			fmt.Fprintf(w, " conversation:\t%d\n", activeStats.Conversation)
			fmt.Fprintf(w, " reasoning:\t%d\n", activeStats.Reasoning)
		}

		serverStatus := thinktI18n.T("indexer.embeddings.status.serverNotRunning", "not running")
		if serverRunning {
			if serverModel != "" && serverModel != modelID {
				serverStatus = thinktI18n.Tf("indexer.embeddings.status.serverRunningModel", "running (model: %s)", serverModel)
			} else if serverEmbedding {
				serverStatus = thinktI18n.T("indexer.embeddings.status.serverEmbedding", "embedding")
				if embedProgress != nil {
					serverStatus += fmt.Sprintf(" %d/%d sessions", embedProgress.Done, embedProgress.Total)
					if embedProgress.ChunksTotal > 0 {
						serverStatus += fmt.Sprintf("  %d/%d chunks", embedProgress.ChunksDone, embedProgress.ChunksTotal)
					}
					if embedProgress.SessionID != "" {
						sid := embedProgress.SessionID
						if len(sid) > 8 {
							sid = sid[:8]
						}
						serverStatus += fmt.Sprintf(" [%s]", sid)
					}
				}
			} else {
				serverStatus = thinktI18n.T("indexer.embeddings.status.serverIdle", "idle")
			}
		}
		fmt.Fprintf(w, "%s\t%s\n", thinktI18n.T("indexer.embeddings.status.serverLabel", "Server:"), serverStatus)
		w.Flush()

		return nil
	},
}

var embeddingsSyncCmd = &cobra.Command{
	Use:   "sync",
	Short: "Run embedding sync (download model if needed, embed all sessions)",
	Args:  cobra.NoArgs,
	RunE: func(cmdObj *cobra.Command, args []string) error {
		cfg, err := config.Load()
		if err != nil {
			cfg = config.Default()
		}

		// Try RPC first
		if rpc.ServerAvailable() {
			sp := NewSyncProgress()
			var progressFn func(rpc.Progress)
			if sp.ShouldShowProgress(quiet, verbose) {
				var lastSessionDone, lastSessionTotal, lastEntries int
				var sessionStart time.Time
				progressFn = func(p rpc.Progress) {
					var data struct {
						ModelDownload bool    `json:"model_download"`
						Percent       float64 `json:"percent"`
						Done          int     `json:"done"`
						Total         int     `json:"total"`
						Chunks        int     `json:"chunks"`
						Entries       int     `json:"entries"`
						ChunksDone    int     `json:"chunks_done"`
						ChunksTotal   int     `json:"chunks_total"`
						TokensDone    int     `json:"tokens_done"`
						SessionID     string  `json:"session_id"`
						ElapsedMs     int64   `json:"elapsed_ms"`
					}
					if err := json.Unmarshal(p.Data, &data); err == nil {
						if data.ModelDownload {
							sp.RenderDownload(cfg.Embedding.Model, data.Percent/100)
						} else if data.ChunksTotal > 0 {
							sid := data.SessionID
							if len(sid) > 8 {
								sid = sid[:8]
							}
							detail := fmt.Sprintf("%s · %d entries · %d/%d chunks", sid, lastEntries, data.ChunksDone, data.ChunksTotal)
							if data.TokensDone > 0 && !sessionStart.IsZero() {
								if secs := time.Since(sessionStart).Seconds(); secs > 0 {
									detail += fmt.Sprintf("  %.0f tok/s", float64(data.TokensDone)/secs)
								}
							}
							sp.RenderEmbedding(lastSessionDone, lastSessionTotal, detail)
						} else if data.Total > 0 {
							lastSessionDone = data.Done
							lastSessionTotal = data.Total
							sid := data.SessionID
							if len(sid) > 8 {
								sid = sid[:8]
							}
							if data.ElapsedMs > 0 {
								elapsed := time.Duration(data.ElapsedMs) * time.Millisecond
								detail := fmt.Sprintf("%s · %d chunks (%s)", sid, data.Chunks, elapsed.Round(time.Millisecond))
								sp.RenderEmbedding(data.Done, data.Total, detail)
							} else {
								lastEntries = data.Entries
								sessionStart = time.Now()
								detail := fmt.Sprintf("%s · %d entries", sid, data.Entries)
								sp.RenderEmbedding(data.Done, data.Total, detail)
							}
						}
					}
				}
			}
			resp, err := rpc.Call(rpc.MethodEmbedSync, rpc.EmbedSyncParams{}, progressFn)
			if err != nil {
				if sp.ShouldShowProgress(quiet, verbose) {
					sp.Finish()
				}
				fmt.Fprint(os.Stderr, thinktI18n.Tf("indexer.embeddings.sync.rpcFallback", "RPC embed_sync failed, falling back to inline: %v\n", err))
			} else if !resp.OK {
				if sp.ShouldShowProgress(quiet, verbose) {
					sp.Finish()
				}
				return fmt.Errorf("embed_sync: %s", resp.Error)
			} else {
				if sp.ShouldShowProgress(quiet, verbose) {
					sp.Finish()
				}
				if !quiet {
					fmt.Println(thinktI18n.T("indexer.embeddings.sync.completeViaServer", "Embedding sync complete (via server)."))
				}
				return nil
			}
		}

		// Inline fallback

		if !cfg.Embedding.Enabled {
			return fmt.Errorf("%s", thinktI18n.T("indexer.embeddings.sync.notEnabled", "embedding is not enabled (run: thinkt-indexer embeddings enable)"))
		}

		modelID := cfg.Embedding.Model
		dlSp := NewSyncProgress()
		if err := embedding.EnsureModel(modelID, func(downloaded, total int64) {
			if total > 0 && dlSp.ShouldShowProgress(quiet, verbose) {
				dlSp.RenderDownload(modelID, float64(downloaded)/float64(total))
			}
		}); err != nil {
			return fmt.Errorf("failed to download embedding model: %w", err)
		}
		if dlSp.ShouldShowProgress(quiet, verbose) {
			dlSp.Finish()
		}

		embedder, err := embedding.NewEmbedder(modelID, "")
		if err != nil {
			return fmt.Errorf("failed to create embedder: %w", err)
		}
		defer embedder.Close()

		database, err := getDB()
		if err != nil {
			return fmt.Errorf("%s", thinktI18n.T("indexer.embeddings.sync.dbLocked", "index database is locked by another process (likely 'thinkt-indexer serve'); use the server's embed sync instead"))
		}
		defer database.Close()

		embDB, err := getEmbeddingsDB(modelID, embedder.Dim())
		if err != nil {
			return fmt.Errorf("%s", thinktI18n.T("indexer.embeddings.sync.embDbLocked", "embeddings database is locked by another process; use 'thinkt-indexer serve' to allow concurrent access"))
		}
		defer embDB.Close()

		registry := cmd.CreateSourceRegistryFiltered(cfg.Indexer.Sources)
		ingester := indexer.NewIngester(database, embDB, registry, embedder)
		ingester.Verbose = verbose

		ctx := context.Background()

		sp := NewSyncProgress()
		if sp.ShouldShowProgress(quiet, verbose) {
			var inlineDone, inlineTotal, inlineEntries int
			var inlineSessionStart time.Time
			ingester.OnEmbedProgress = func(done, total, chunks, entries int, sessionID, sessionPath string, elapsed time.Duration) {
				inlineDone = done
				inlineTotal = total
				sid := sessionID[:min(8, len(sessionID))]
				if elapsed == 0 {
					inlineEntries = entries
					inlineSessionStart = time.Now()
					sp.RenderEmbedding(done, total, fmt.Sprintf("%s · %d entries", sid, entries))
				} else {
					sp.RenderEmbedding(done, total, fmt.Sprintf("%s · %d chunks (%s)", sid, chunks, elapsed.Round(time.Millisecond)))
				}
			}
			ingester.OnEmbedChunkProgress = func(chunksDone, chunksTotal, tokensDone int, sessionID string) {
				sid := sessionID[:min(8, len(sessionID))]
				detail := fmt.Sprintf("%s · %d entries · %d/%d chunks", sid, inlineEntries, chunksDone, chunksTotal)
				if tokensDone > 0 && !inlineSessionStart.IsZero() {
					if secs := time.Since(inlineSessionStart).Seconds(); secs > 0 {
						detail += fmt.Sprintf("  %.0f tok/s", float64(tokensDone)/secs)
					}
				}
				sp.RenderEmbedding(inlineDone, inlineTotal, detail)
			}
		}

		if err := ingester.EmbedAllSessions(ctx); err != nil {
			return fmt.Errorf("embedding error: %w", err)
		}

		if sp.ShouldShowProgress(quiet, verbose) {
			sp.Finish()
		}

		if !quiet {
			fmt.Println(thinktI18n.T("indexer.embeddings.sync.complete", "Embedding sync complete."))
		}
		return nil
	},
}


func formatBytes(b int64) string {
	const (
		kb = 1024
		mb = 1024 * kb
		gb = 1024 * mb
	)
	switch {
	case b >= gb:
		return fmt.Sprintf("%.1f GB", float64(b)/float64(gb))
	case b >= mb:
		return fmt.Sprintf("%.1f MB", float64(b)/float64(mb))
	case b >= kb:
		return fmt.Sprintf("%.1f KB", float64(b)/float64(kb))
	default:
		return fmt.Sprintf("%d B", b)
	}
}

func init() {
	embeddingsCmd.Flags().BoolVar(&embeddingsListJSON, "json", false, "Output as JSON")
	embeddingsListCmd.Flags().BoolVar(&embeddingsListJSON, "json", false, "Output as JSON")
	embeddingsCmd.AddCommand(embeddingsListCmd)
	embeddingsCmd.AddCommand(embeddingsPurgeCmd)
	embeddingsCmd.AddCommand(embeddingsEnableCmd)
	embeddingsCmd.AddCommand(embeddingsDisableCmd)
	embeddingsCmd.AddCommand(embeddingsModelCmd)
	embeddingsStatusCmd.Flags().BoolVar(&embeddingsStatusJSON, "json", false, "Output as JSON")
	embeddingsCmd.AddCommand(embeddingsStatusCmd)
	embeddingsCmd.AddCommand(embeddingsSyncCmd)
	rootCmd.AddCommand(embeddingsCmd)
}
